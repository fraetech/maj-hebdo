<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Modifications ANFR hebdomadaires</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Didact+Gothic&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css" />
  <link rel="icon" href="https://raw.githubusercontent.com/fraetech/maj-hebdo/refs/heads/data/icons/favicon.svg" type="image/svg+xml">
  <style>
    * {
      font-family: "Didact Gothic", sans-serif !important;
      font-weight: 500;
      font-style: normal;
    }

    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }

    #map {
      height: 100%;
      width: 100%;
      z-index: 1;
    }

    #message {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000;
      background-color: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
      width: 90%;
      max-width: 400px;
      text-align: center;
    }

    #closeButton {
      position: absolute;
      top: 5px;
      right: 5px;
      background-color: transparent;
      border: none;
      font-size: 20px;
      font-weight: bold;
      cursor: pointer;
    }

    /* Styles pour l'icône de recherche */
    .leaflet-control.search-icon-control {
      background: white;
      width: 30px;
      height: 30px;
      margin-left: 11px;
      border-radius: 2px;
      box-shadow: 0 1px 5px rgba(0,0,0,0.65);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #333;
    }

    .leaflet-control.search-icon-control svg {
      display: block;
    }

    .leaflet-control.search-icon-control:hover {
      background-color: #f4f4f4;
    }

    /* Styles pour la search box */
    .leaflet-control.search-control {
      background: white;
      padding: 8px;
      border-radius: 6px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      width: 320px;
      position: relative;
      display: none;
    }

    .leaflet-control.search-control.expanded {
      display: block;
    }

    .clear-search-btn {
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      background: none;
      border: none;
      font-size: 18px;
      color: #666;
      cursor: pointer;
      padding: 0;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
    }

    .clear-search-btn:hover {
      background-color: #f0f0f0;
      color: #333;
    }

    .search-input {
      width: 100%;
      padding: 8px 40px 8px 12px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 14px;
      box-sizing: border-box;
    }

    /* Centrer la search box en haut */
    .leaflet-top.leaflet-center {
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      justify-content: center;
    }

    .search-results {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: white;
      border: 1px solid #ccc;
      border-top: none;
      border-radius: 0 0 4px 4px;
      max-height: 200px;
      overflow-y: auto;
      z-index: 1000;
      display: none;
    }

    .search-result-item {
      padding: 8px 12px;
      cursor: pointer;
      border-bottom: 1px solid #eee;
      font-size: 13px;
      position: relative;
    }

    .search-result-item.has-operator {
      padding-left: 20px;
    }

    .search-result-item.has-operator::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 4px;
      background-color: var(--operator-color);
    }

    .search-result-item:hover {
      background-color: #f0f0f0;
    }

    .search-result-item:last-child {
      border-bottom: none;
    }

    .search-result-type {
      font-size: 11px;
      color: #666;
      font-weight: bold;
      text-transform: uppercase;
    }

    .search-result-main {
      margin-top: 2px;
    }

    .search-result-detail {
      font-size: 11px;
      color: #888;
      margin-top: 2px;
    }

    .leaflet-control.custom-filter-control {
      background: white;
      padding: 10px;
      border-radius: 6px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      font-size: 14px;
      width: 250px;
      max-height: 80vh;
      overflow-y: auto;
    }

    .filter-category {
      font-weight: bold;
      margin-top: 10px;
      cursor: pointer;
      background: #f1f1f1;
      padding: 5px;
      border-radius: 4px;
    }

    .filter-group {
      display: block;
      padding-left: 10px;
      margin-top: 5px;
      max-height: 0;
      overflow: hidden;
    }

    .filter-group label {
      display: block;
      margin: 4px 0;
    }
    
    .leaflet-control.custom-filter-control.collapsed {
      width: auto;
      height: auto;
      padding: 6px 10px;
      font-weight: bold;
      cursor: pointer;
      text-align: center;
    }
    
    .leaflet-control.custom-filter-control.collapsed::after {
      content: "Filtres";
    }
    
    .leaflet-control.custom-filter-control.expanded {
      transition: all 0.3s ease;
      width: 250px;
      padding: 10px;
    }
    
    .filter-group {
      transition: max-height 0.3s ease;
      overflow: hidden;
    }

    .reset-filters {
      display: block;
      margin: 10px 0;
      padding: 6px 10px;
      background-color: #f1f1f1;
      border: 1px solid #ccc;
      border-radius: 4px;
      cursor: pointer;
      text-align: center;
      font-weight: bold;
    }

    .reset-filters:hover {
      background-color: #e0e0e0;
    }

    /* Styles pour les popups */
    .leaflet-popup-content {
      text-align: center;
      margin: 10px;
    }

    .bandeau {
      margin: -12px -20px 10px -20px;
      padding: 10px;
      text-align: center;
      border-radius: 12px 12px 0 0;
    }

    .bandeau a {
      text-decoration: none;
      font-weight: bold;
    }

    .icone-container {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin: 12px 0;
    }

    .icone {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 50px;
      height: 50px;
      border-radius: 8px;
      background-color: #f5f5f5;
      padding: 5px;
      transition: all 0.2s ease;
    }

    .icone:hover {
      background-color: #e0e0e0;
      transform: scale(1.05);
    }

    .icone img {
      max-width: 40px;
      max-height: 40px;
    }

    .titre {
      margin: 8px 0;
    }

    .contenu {
      margin: 12px 0;
      text-align: left;
    }

    .action-groupe {
      margin-bottom: 8px;
    }

    .action-titre {
      font-weight: bold;
      margin-bottom: 4px;
    }

    strong { font-weight: bold; }

    /* Responsive design */
    @media (max-width: 768px) {
      .leaflet-control.search-control {
        width: calc(100vw - 40px);
        max-width: 320px;
      }
      
      .leaflet-control.custom-filter-control.expanded {
        width: calc(100vw - 40px);
        max-width: 250px;
      }
      
      .search-input {
        font-size: 16px; /* Évite le zoom sur iOS */
      }
      
      .leaflet-top.leaflet-center {
        left: 20px;
        right: 20px;
        transform: none;
        justify-content: stretch;
      }
      
      .leaflet-control.search-icon-control {
        margin-left: 0;
      }
    }

    @media (max-width: 480px) {
      .leaflet-control.search-control {
        width: calc(100vw - 40px);
      }
      
      .leaflet-control.custom-filter-control.expanded {
        width: calc(100vw - 20px);
      }
      
      .leaflet-top.leaflet-center {
        left: 10px;
        right: 10px;
      }
      
      .search-input::placeholder {
        font-size: 13px;
      }
    }
      </style>
    </head>
<body>

  <div id="message">
    <button id="closeButton">&times;</button>
    <h4><strong>Chargement... (peut prendre du temps sur les grosses MAJs)</strong></h4>
    <p>Vous pouvez filtrer les supports à afficher à l'aide du bouton "Filtres" (en haut à droite).<br>
    Questions, remarques et suggestions :<br> <a href='https://github.com/fraetech/maj-hebdo/issues' target='_blank'>GitHub MAJ-Hebdo</a><br>
    L'historique (sur un an) des mises à jour c'est par ici : <br>
    <a href='https://fraetech.github.io/maj-hebdo/history.html' target="_self">Historique des mises à jour</a><br>
    Une carte propre à chaque opérateur est également disponible :<br>
    <a href='https://fraetech.github.io/maj-hebdo/' target="_self">Tous</a> (cette carte),
    <a href='https://fraetech.github.io/maj-hebdo/bouygues.html' target="_self">Bouygues</a>,
    <a href='https://fraetech.github.io/maj-hebdo/free.html' target="_self">Free</a>,
    <a href='https://fraetech.github.io/maj-hebdo/orange.html' target="_self">Orange</a> et
    <a href='https://fraetech.github.io/maj-hebdo/sfr.html' target="_self">SFR</a><br>
    <b>Source :</b> <a href='https://data.anfr.fr/visualisation/information/?id=observatoire_2g_3g_4g' target='_blank'>OpenData ANFR</a> | <small>v25.08.15b (B)</small></p>
  </div>

  <div id="map"></div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>
  <script>
    // Configuration centralisée
    const CONFIG = {
      operators: {
        'ORANGE': { id: 'ora', color: '#FD7B02' },
        'FREE MOBILE': { id: 'fmb', color: '#6D6E71' },
        'SFR': { id: 'sfr', color: '#E40012' },
        'BOUYGUES TELECOM': { id: 'byt', color: '#009BCE' },
        'TELCO OI': { id: 'fmb', color: '#6D6E71' },
        'SRR': { id: 'sfr', color: '#E40012' },
        'FREE CARAIBES': { id: 'fmb', color: '#6D6E71' },
        'ZEOP': { id: 'zop', color: '#681260' },
        'DIGICEL': { id: 'dig', color: '#E4002B' },
        'GOUV NELLE CALEDONIE (OPT)': { id: 'opt', color: '#292C83' },
        'OUTREMER TELECOM': { id: 'ott', color: '#DE006F' },
        'PMT/VODAFONE': { id: 'pmt', color: '#FF0E00' },
        'MISC': { id: 'misc', color: '#000000' }
      },
      actions: {
        'ALL': 'Activation fréquence',
        'AJO': 'Ajout fréquence',
        'SUP': 'Suppression fréquence',
        'EXT': 'Extinction fréquence',
        'AAV': 'Activation prévisionnelles'
      },
      technologies: {
        'GSM': 'GSM (2G)',
        'UMTS': 'UMTS (3G)',
        'LTE': 'LTE (4G)',
        '5G NR': 'NR (5G)'
      },
      techOrder: ['GSM', 'UMTS', 'LTE', '5G NR'],
      baseIconUrl: 'https://raw.githubusercontent.com/fraetech/maj-hebdo/refs/heads/data/icons/',
      baseDataUrl: 'https://raw.githubusercontent.com/fraetech/maj-hebdo/refs/heads/data/files/'
    };

    // Store unifié pour toutes les données
    class DataStore {
      constructor() {
        this.supports = new Map(); // supportKey -> {marker, data, coords}
        this.searchIndex = new Map(); // Pour recherche rapide
        this.filterValues = {
          operateurs: new Set(),
          technos: new Set(),
          freqs: new Set(),
          actions: new Set()
        };
        this.activeFilters = {
          operateurs: new Set(),
          technos: new Set(),
          freqs: new Set(),
          actions: new Set(),
          zb: new Set(['true', 'false']),
          new: new Set(['true', 'false'])
        };
      }

      addSupport(supportKey, data) {
        this.supports.set(supportKey, data);
        
        // Indexer pour la recherche - MODIFIER ICI
        const supportId = data.data[0].id_support;
        const address = data.data[0].adresse;
        
        if (!this.searchIndex.has('support')) this.searchIndex.set('support', new Map());
        if (!this.searchIndex.has('address')) this.searchIndex.set('address', new Map());
        
        // Stocker dans des arrays pour gérer les doublons
        const supportIndex = this.searchIndex.get('support');
        const addressIndex = this.searchIndex.get('address');
        
        if (!supportIndex.has(supportId.toLowerCase())) {
            supportIndex.set(supportId.toLowerCase(), []);
        }
        if (!addressIndex.has(address.toLowerCase())) {
            addressIndex.set(address.toLowerCase(), []);
        }
        
        supportIndex.get(supportId.toLowerCase()).push({ supportKey, data });
        addressIndex.get(address.toLowerCase()).push({ supportKey, data });
        
        // Collecter les valeurs pour les filtres
        data.data.forEach(row => {
            this.filterValues.operateurs.add(row.operateur);
            this.filterValues.actions.add(row.action);
            
            row.technologie.split(',').forEach(tech => {
            const cleanTech = tech.trim();
            const baseTech = this.extractBaseTech(cleanTech);
            const freq = this.extractFreq(cleanTech);
            
            this.filterValues.technos.add(baseTech);
            if (freq) this.filterValues.freqs.add(freq);
            });
        });
        }

      extractBaseTech(tech) {
        return tech.replace(/\s*\d{3,4}$/, '').trim();
      }

      extractFreq(tech) {
        return (tech.match(/(\d{3,4})$/) || [])[1] || null;
      }

      search(query, type) {
        const results = [];
        const queryLower = query.toLowerCase();
        const index = this.searchIndex.get(type);
        
        if (!index) return results;
        
        for (const [key, valueArray] of index) {
            if (key.includes(queryLower)) {
            // Traiter tous les résultats pour cette clé
            valueArray.forEach(value => {
                const firstRow = value.data.data[0];
                const [lat, lon] = firstRow.coordonnees.split(',').map(parseFloat);
                
                results.push({
                type,
                display: type === 'support' ? `Support ${firstRow.id_support}` : firstRow.adresse,
                detail: type === 'support' 
                    ? `${firstRow.operateur} - ${firstRow.adresse}`
                    : `Support ${firstRow.id_support} - ${firstRow.operateur}`,
                marker: value.data.marker,
                lat, lon,
                operator: firstRow.operateur
                });
            });
            }
        }
        
        return results;
        }

      getFilteredSupports() {
        const filtered = [];
        
        for (const [supportKey, supportData] of this.supports) {
          let shouldDisplay = false;
          
          for (const row of supportData.data) {
            if (this.matchesFilters(row)) {
              shouldDisplay = true;
              break;
            }
          }
          
          if (shouldDisplay) {
            filtered.push(supportData);
          }
        }
        
        return filtered;
      }

      isResultFilteredOut(result) {
        // Vérifier si l'opérateur est filtré
        if (!this.activeFilters.operateurs.has(result.operator)) {
            return true;
        }
        
        // Ici on pourrait ajouter d'autres vérifications si nécessaire
        return false;
        }

      matchesFilters(row) {
        const matchOp = this.activeFilters.operateurs.has(row.operateur);
        const matchAction = this.activeFilters.actions.has(row.action);
        const matchZB = this.activeFilters.zb.has(row.is_zb);
        const matchNew = this.activeFilters.new.has(row.is_new);
        
        const techFreqMatch = row.technologie.split(',').some(tech => {
          const cleanTech = tech.trim();
          const baseTech = this.extractBaseTech(cleanTech);
          const freq = this.extractFreq(cleanTech);
          return this.activeFilters.technos.has(baseTech) && this.activeFilters.freqs.has(freq);
        });
        
        return matchOp && matchAction && matchZB && matchNew && techFreqMatch;
      }

      updateActiveFilters(filterType, values) {
        this.activeFilters[filterType] = values;
      }
    }

    // Gestionnaire de carte
    class MapManager {
      constructor() {
        this.map = L.map('map').setView([46.5, 2.5], 6);
        this.markerCluster = L.markerClusterGroup();
        this.initBaseLayers();
      }

      initBaseLayers() {
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: '&copy; OpenStreetMap contributors'
        }).addTo(this.map);
        
        this.map.addLayer(this.markerCluster);
      }

      updateMarkers(supports) {
        this.markerCluster.clearLayers();
        supports.forEach(support => {
          this.markerCluster.addLayer(support.marker);
        });
      }

      addControls() {
        this.map.addControl(new SearchIconControl({ position: 'topleft' }));
        this.map.addControl(new SearchControl({ position: 'topleft' }));
        this.map.addControl(new FilterControl({ position: 'topright' }));
      }
    }

    // Générateur de contenu popup
    class PopupGenerator {
      static generate(actionsData) {
        if (!actionsData || actionsData.length === 0) return '';
        
        const firstAction = actionsData[0];
        const [lat, lon] = firstAction.coordonnees.split(',').map(s => s.trim());
        
        return `
          ${this.generateBandeau(firstAction, lat, lon)}
          ${this.generateIcons(firstAction, lat, lon)}
          ${this.generateTitle(firstAction)}
          ${this.generateActions(actionsData)}
          ${this.generateFooter(firstAction)}
        `;
      }

      static generateBandeau(firstAction, lat, lon) {
        const color = CONFIG.operators[firstAction.operateur]?.color || '#000000';
        const link = `https://data.anfr.fr/visualisation/map/?id=observatoire_2g_3g_4g&location=17,${lat},${lon}`;
        
        return `<div class="bandeau" style="background-color: ${color};">
          <a href='${link}' target='_blank' style='color:#FFFFFF;'>Support n°${firstAction.id_support}</a>
        </div>`;
      }

      static generateIcons(firstAction, lat, lon) {
        let icons = `
          <a href='https://cartoradio.fr/index.html#/cartographie/lonlat/${lon}/${lat}' target='_blank' class="icone">
            <img src="${CONFIG.baseIconUrl}cartoradio.avif" alt="Cartoradio">
          </a>
          <a href='https://www.google.fr/maps/place/${lat},${lon}' target='_blank' class="icone">
            <img src="${CONFIG.baseIconUrl}maps.avif" alt="Google Maps">
          </a>`;
        
        if (['FREE MOBILE', 'TELCO OI'].includes(firstAction.operateur)) {
          icons += `<a href='https://rncmobile.net/site/${lat},${lon}' target='_blank' class="icone">
            <img src="${CONFIG.baseIconUrl}rnc.avif" alt="RNC Mobile">
          </a>`;
        }
        
        return `<div class="icone-container">${icons}</div>`;
      }

      static generateTitle(firstAction) {
        return `<div class="titre"><strong>${firstAction.adresse}</strong></div>`;
      }

      static generateActions(actionsData) {
        const actionsByType = {};
        actionsData.forEach(action => {
          if (!actionsByType[action.action]) actionsByType[action.action] = [];
          actionsByType[action.action].push(action);
        });

        let html = '<div class="contenu">';
        for (const [actionType, actions] of Object.entries(actionsByType)) {
          const actionTitle = CONFIG.actions[actionType] || actionType;

          if (actionType === 'AAV') {
            html += `<div class="action-groupe">
              <div class="action-titre">Activation prévisionnelle :</div>
              <div>${actions.map(a => {
                let dateBrackets = '';
                if (a.date_activ) {
                  const [y, m, d] = a.date_activ.split('-');
                  dateBrackets = ` [Activation prévue le : ${d}/${m}/${y}]`;
                }
                return `${a.technologie}${dateBrackets}`;
              }).join('<br>')}</div>
            </div>`;
          }
          else {
            html += `<div class="action-groupe">
              <div class="action-titre">${actionTitle} :</div>
              <div>${actions.map(a => a.technologie).join('<br>')}</div>
            </div>`;
          }
        }
        html += '</div>';

        return html;
      }


      static generateFooter(firstAction) {
        return `<div class="titre">${firstAction.type_support} - ${firstAction.hauteur_support} - ${firstAction.proprietaire_support}</div>`;
      }
    }

    // Gestionnaire de recherche
    class SearchManager {
      constructor(dataStore) {
        this.dataStore = dataStore;
        this.mapManager = mapManager;
        this.searchTimeout = null;
        this.currentResults = [];
      }

      async handleInput(query) {
        clearTimeout(this.searchTimeout);
        
        if (query.length < 2) {
            this.hideResults();
            return;
        }
        
        this.searchTimeout = setTimeout(async () => {
            try {
            // Recherche dans les données locales
            let supportResults = this.dataStore.search(query, 'support');
            let addressResults = this.dataStore.search(query, 'address');
            
            // Filtrer selon les filtres actifs
            supportResults = supportResults.filter(result => !this.dataStore.isResultFilteredOut(result));
            addressResults = addressResults.filter(result => !this.dataStore.isResultFilteredOut(result));
            
            // Recherche géographique (Nominatim)
            const locationResults = await this.searchNominatim(query);
            
            // Tri existant...
            const sortedSupportResults = supportResults.sort((a, b) => {
                const opA = a.detail.split(' - ')[0];
                const opB = b.detail.split(' - ')[0];
                if (opA !== opB) return opA.localeCompare(opB);
                return a.detail.split(' - ')[1].localeCompare(b.detail.split(' - ')[1]);
            });
            
            const sortedAddressResults = addressResults.sort((a, b) => {
                const opA = a.detail.split(' - ')[1];
                const opB = b.detail.split(' - ')[1];
                if (opA !== opB) return opA.localeCompare(opB);
                return a.display.localeCompare(b.display);
            });
            
            this.currentResults = [
                ...locationResults,
                ...sortedSupportResults,
                ...sortedAddressResults
            ];
            
            this.displayResults();
            } catch (error) {
            console.error('Erreur recherche:', error);
            }
        }, 300);
        }

      async searchNominatim(query) {
        try {
            const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&limit=10&countrycodes=fr&q=${encodeURIComponent(query)}`);
            const data = await response.json();
            
            // Filtrer pour garder le meilleur résultat par ville/lieu
            const seenPlaces = new Set();
            const filteredResults = [];
            
            for (const item of data) {
            // Priorité aux types : city, town, village, hamlet
            const preferredTypes = ['city', 'town', 'village', 'hamlet', 'municipality'];
            const isPreferredType = preferredTypes.includes(item.type) || preferredTypes.includes(item.class);
            
            // Extraire le nom principal de la ville depuis display_name
            const placeName = item.display_name.split(',')[0].trim().toLowerCase();
            
            // Si on n'a pas encore ce lieu OU si c'est un type préféré, on l'ajoute
            if (!seenPlaces.has(placeName) || isPreferredType) {
                if (!seenPlaces.has(placeName)) {
                filteredResults.push({
                    type: 'location',
                    display: item.display_name,
                    lat: parseFloat(item.lat),
                    lon: parseFloat(item.lon),
                    importance: item.importance || 0
                });
                seenPlaces.add(placeName);
                }
            }
            
            if (filteredResults.length >= 1) break; // Limiter à 1 résultat au lieu de 3
            }
            
            return filteredResults;
        } catch (error) {
            console.error('Erreur Nominatim:', error);
            return [];
        }
        }

      displayResults() {
        const container = document.getElementById('searchResults');
        container.innerHTML = '';
        
        if (this.currentResults.length === 0) {
          container.style.display = 'none';
          return;
        }
        
        this.currentResults.forEach(result => {
          const item = this.createResultItem(result);
          container.appendChild(item);
        });
        
        container.style.display = 'block';
      }

      createResultItem(result) {
        const item = document.createElement('div');
        item.className = 'search-result-item';
        
        const typeLabels = {
          support: 'Support ID',
          address: 'Adresse antenne',
          location: 'Lieu'
        };
        
        if (result.operator && CONFIG.operators[result.operator]) {
          item.classList.add('has-operator');
          item.style.setProperty('--operator-color', CONFIG.operators[result.operator].color);
        }
        
        item.innerHTML = `
          <div class="search-result-type">${typeLabels[result.type] || result.type}</div>
          <div class="search-result-main">${result.display}</div>
          ${result.detail ? `<div class="search-result-detail">${result.detail}</div>` : ''}
        `;
        
        item.addEventListener('click', () => this.selectResult(result));
        return item;
      }

      selectResult(result) {
        this.hideResults();
        document.getElementById('searchInput').value = result.display;
        
        // S'assurer que mapManager est accessible
        const mapManager = this.dataStore.mapManager || app?.mapManager;
        if (mapManager) {
            mapManager.map.setView([result.lat, result.lon], 15);
            
            if (result.marker) {
            setTimeout(() => result.marker.openPopup(), 500);
            }
        }
        }

      hideResults() {
        const searchResults = document.getElementById('searchResults');
        if (searchResults) {
          searchResults.style.display = 'none';
        }
        this.currentResults = [];
      }

      hideSearchBar() {
        const searchControl = document.querySelector('.search-control');
        if (searchControl) {
          searchControl.classList.remove('expanded');
        }
        this.hideResults();
      }
    }

    // Gestionnaire de filtres
    class FilterManager {
      constructor(dataStore, mapManager) {
        this.dataStore = dataStore;
        this.mapManager = mapManager;
        this.updateTimeout = null;
      }

      initFilters() {
        this.createFilterGroups();
        this.attachEvents();
      }

      createFilterGroups() {
        // Opérateurs triés alphabétiquement
        const sortedOperators = [...this.dataStore.filterValues.operateurs].sort();
        sortedOperators.forEach(op => 
          this.createCheckbox('opFilters', op, 'operateurs', op)
        );
        
        // Technologies dans l'ordre des générations
        const sortedTechs = [...this.dataStore.filterValues.technos]
          .sort((a, b) => CONFIG.techOrder.indexOf(a) - CONFIG.techOrder.indexOf(b));
        sortedTechs.forEach(tech => 
          this.createCheckbox('technoFilters', tech, 'technos', CONFIG.technologies[tech] || tech)
        );
        
        // Fréquences triées numériquement
        const sortedFreqs = [...this.dataStore.filterValues.freqs]
          .map(Number).sort((a, b) => a - b).map(String);
        sortedFreqs.forEach(freq => 
          this.createCheckbox('freqFilters', freq, 'freqs', freq)
        );
        
        // Actions
        [...this.dataStore.filterValues.actions].sort().forEach(action => 
          this.createCheckbox('actionFilters', action, 'actions', CONFIG.actions[action] || action)
        );
        
        // Radio groups
        this.createRadioGroup('zbFilter', 'zoneBlanche', [
          { value: 'all', label: 'Toutes' },
          { value: 'true', label: 'Zone blanche' },
          { value: 'false', label: 'Non zone blanche' }
        ]);
        
        this.createRadioGroup('newSiteFilter', 'siteNeuf', [
          { value: 'all', label: 'Tous' },
          { value: 'true', label: 'Site neuf' },
          { value: 'false', label: 'Site existant' }
        ]);
      }

      createCheckbox(containerId, value, filterType, displayName) {
        const container = document.getElementById(containerId);
        const label = document.createElement('label');
        const checkbox = document.createElement('input');
        
        checkbox.type = 'checkbox';
        checkbox.value = value;
        checkbox.checked = true;
        checkbox.addEventListener('change', () => this.updateFilters());
        
        label.appendChild(checkbox);
        label.append(' ' + displayName);
        container.appendChild(label);
        
        this.dataStore.activeFilters[filterType].add(value);
      }

      createRadioGroup(containerId, name, options) {
        const container = document.getElementById(containerId);
        options.forEach((option, index) => {
          const label = document.createElement('label');
          const radio = document.createElement('input');
          
          radio.type = 'radio';
          radio.name = name;
          radio.value = option.value;
          radio.checked = index === 0;
          radio.addEventListener('change', () => this.updateFilters());
          
          label.appendChild(radio);
          label.append(' ' + option.label);
          container.appendChild(label);
        });
      }

      updateFilters() {
        // Débounce pour éviter les appels multiples
        clearTimeout(this.updateTimeout);
        this.updateTimeout = setTimeout(() => {
            this._doUpdateFilters();
        }, 100);
        }

      _doUpdateFilters() {
        // Collecter les valeurs des checkboxes
        ['operateurs', 'technos', 'freqs', 'actions'].forEach(type => {
          const values = new Set();
          document.querySelectorAll(`#${type === 'operateurs' ? 'op' : type === 'technos' ? 'techno' : type === 'freqs' ? 'freq' : 'action'}Filters input:checked`)
            .forEach(cb => values.add(cb.value));
          this.dataStore.updateActiveFilters(type, values);
        });
        
        // Collecter les valeurs des radios
        ['zoneBlanche', 'siteNeuf'].forEach(name => {
          const radio = document.querySelector(`input[name="${name}"]:checked`);
          const values = radio?.value === 'all' 
            ? new Set(['true', 'false']) 
            : new Set([radio?.value || 'true']);
          this.dataStore.updateActiveFilters(name === 'zoneBlanche' ? 'zb' : 'new', values);
        });
        
        // Mettre à jour l'affichage
        const filteredSupports = this.dataStore.getFilteredSupports();
        this.mapManager.updateMarkers(filteredSupports);
      }

      resetAllFilters() {
        document.querySelectorAll('.filter-group input[type="checkbox"]').forEach(cb => cb.checked = true);
        document.querySelectorAll('input[name="zoneBlanche"][value="all"], input[name="siteNeuf"][value="all"]')
          .forEach(radio => radio.checked = true);
        this.updateFilters();
      }

      attachEvents() {
        // Event delegation pour les filtres
        document.addEventListener('click', (e) => {
          if (e.target.matches('.filter-group input')) {
            e.stopPropagation();
          }
          if (e.target.matches('#resetFilters')) {
            e.stopPropagation();
            this.resetAllFilters();
          }
        });

        // Gestion des catégories de filtres
        document.querySelectorAll('.filter-category').forEach(cat => {
          cat.addEventListener('click', (e) => {
            e.stopPropagation();
            const group = cat.nextElementSibling;
            group.style.maxHeight = group.style.maxHeight ? null : group.scrollHeight + "px";
          });
        });
      }
    }

    // Contrôles Leaflet
    const SearchIconControl = L.Control.extend({
      onAdd: function(map) {
        const div = L.DomUtil.create('div', 'leaflet-control search-icon-control');
        div.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="11" cy="11" r="8"></circle>
          <path d="m21 21-4.35-4.35"></path>
        </svg>`;
        div.title = 'Rechercher';
        
        div.addEventListener('click', (e) => {
          e.stopPropagation();
          const searchControl = document.querySelector('.search-control');
          if (searchControl) {
            searchControl.classList.add('expanded');
            const input = document.getElementById('searchInput');
            if (input) {
              setTimeout(() => input.focus(), 100);
            }
          }
        });
        
        L.DomEvent.disableClickPropagation(div);
        return div;
      }
    });

    const SearchControl = L.Control.extend({
      onAdd: function(map) {
        const div = L.DomUtil.create('div', 'leaflet-control search-control');
        div.innerHTML = `
          <div style="position: relative;">
            <input type="text" id="searchInput" class="search-input" placeholder="Rechercher une ville, adresse, ou support ID...">
            <button id="clearSearch" class="clear-search-btn" style="display: none;" type="button">&times;</button>
          </div>
          <div id="searchResults" class="search-results"></div>
        `;
        L.DomEvent.disableClickPropagation(div);
        L.DomEvent.disableScrollPropagation(div);
        return div;
      }
    });

    const FilterControl = L.Control.extend({
      onAdd: function(map) {
        const div = L.DomUtil.create('div', 'leaflet-control custom-filter-control collapsed');
        div.innerHTML = `
          <div class="filters-content" style="display:none;">
            <button class="reset-filters" id="resetFilters">Réinitialiser tous les filtres</button>
            <div class="filter-category">Technologies</div><div class="filter-group" id="technoFilters"></div>
            <div class="filter-category">Fréquences</div><div class="filter-group" id="freqFilters"></div>
            <div class="filter-category">Opérateurs</div><div class="filter-group" id="opFilters"></div>
            <div class="filter-category">Actions</div><div class="filter-group" id="actionFilters"></div>
            <div class="filter-category">Zone Blanche</div><div class="filter-group" id="zbFilter"></div>
            <div class="filter-category">Sites Neufs</div><div class="filter-group" id="newSiteFilter"></div>
          </div>
        `;

        // Empêcher la propagation du scroll vers la carte
        L.DomEvent.disableScrollPropagation(div);

        // Et également après la création du toggle :
        div.addEventListener('click', (e) => {
        // Code existant...
        });

        // Ajouter ceci pour gérer le scroll spécifiquement
        div.addEventListener('wheel', (e) => {
        e.stopPropagation();
        });

        // Toggle du panneau de filtres
        div.addEventListener('click', (e) => {
          if (e.target === div || e.target.classList.contains('filters-content')) {
            if (div.classList.contains('collapsed')) {
              div.classList.remove('collapsed');
              div.classList.add('expanded');
              div.querySelector('.filters-content').style.display = 'block';
            } else if (div.classList.contains('expanded')) {
              div.classList.remove('expanded');
              div.classList.add('collapsed');
              div.querySelector('.filters-content').style.display = 'none';
            }
          }
        });

        return div;
      }
    });

    // Utilitaires
    class Utils {
      static csvToRows(text) {
        const lines = text.trim().split('\n').slice(1);
        return lines.map(line => {
          const values = line.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/).map(v => v.replace(/^"|"$/g, ''));
          return {
            id_support: values[0],
            operateur: values[1],
            action: values[2],
            technologie: values[3],
            adresse: values[4],
            code_insee: values[5],
            coordonnees: values[6],
            type_support: values[7],
            hauteur_support: values[8],
            proprietaire_support: values[9],
            date_activ: values[10],
            is_zb: values[11]?.toLowerCase().trim() || 'false',
            is_new: values[12]?.toLowerCase().trim() || 'false'
          };
        });
      }

      static createMarker(supportData) {
        const firstRow = supportData[0];
        const [lat, lon] = firstRow.coordonnees.split(',').map(parseFloat);
        
        if (isNaN(lat) || isNaN(lon)) return null;

        const opConfig = CONFIG.operators[firstRow.operateur] || CONFIG.operators['MISC'];
        const actionId = supportData.length > 1 ? '' : `_${firstRow.action.toLowerCase()}`;
        let iconUrl;
        
        if (actionId === '_aav') {
          iconUrl = `${CONFIG.baseIconUrl}${opConfig.id}.avif`;
        } else {
          iconUrl = `${CONFIG.baseIconUrl}${opConfig.id}${actionId}.avif`;
        }

        const marker = L.marker([lat, lon], {
          icon: L.icon({
            iconUrl,
            iconSize: [48, 48],
            iconAnchor: [24, 48]
          }),
          title: firstRow.operateur
        });

        marker.bindPopup(PopupGenerator.generate(supportData));
        return marker;
      }

      static getUrlParams() {
        const params = new URLSearchParams(window.location.search);
        const csvPath = params.get('csv');
        
        const baseUrl = CONFIG.baseDataUrl + (csvPath ? `${csvPath}` : 'hebdo/beta');
        
        return {
          csvUrl: `${baseUrl}.csv?t=${Date.now()}`, // Eviter le cache
          timestampUrl: `${baseUrl.replace('index', 'timestamp')}.txt?t=${Date.now()}`
        };
      }
    }

    // Application principale
    class ANFRApp {
      constructor() {
        this.dataStore = new DataStore();
        this.mapManager = new MapManager();
        this.searchManager = new SearchManager(this.dataStore, this.mapManager);
        this.filterManager = new FilterManager(this.dataStore, this.mapManager);
        
        this.init();
      }

      async init() {
        this.setupEventListeners();
        this.mapManager.addControls();
        await this.loadData();
        this.filterManager.initFilters();
        this.initSearch();
      }

      setupEventListeners() {
      // Helper pour masquer le message
      const hideMessage = () => {
        const msg = document.getElementById('message');
        if (msg) msg.style.display = 'none';
      };

      // Fermeture du message d'accueil
      document.getElementById('closeButton')?.addEventListener('click', hideMessage);

      // Fermeture automatique lors du déplacement de carte
      this.mapManager.map.on('movestart', () => {
        hideMessage();
        this.searchManager.hideSearchBar();
        
        // Fermer le panneau de filtres
        const filterPanel = document.querySelector('.leaflet-control.custom-filter-control');
        if (filterPanel?.classList.contains('expanded')) {
          filterPanel.classList.remove('expanded');
          filterPanel.classList.add('collapsed');
          filterPanel.querySelector('.filters-content').style.display = 'none';
        }
      });

      // Masquer le message lors d'un clic sur la carte
      this.mapManager.map.on('click', hideMessage);

      // Masquer le message lors d'un zoom
      this.mapManager.map.on('zoomstart', hideMessage);

      // Fermer la recherche si clic ailleurs
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.search-control') && !e.target.closest('.search-icon-control')) {
          this.searchManager.hideSearchBar();
        }
      });
    }

      async loadData() {
        try {
          const { csvUrl, timestampUrl } = Utils.getUrlParams();
          
          // Charger les données CSV
          const csvResponse = await fetch(csvUrl);
          const csvText = await csvResponse.text();
          const rows = Utils.csvToRows(csvText);
          
          // Charger la date de mise à jour
          try {
            const timestampResponse = await fetch(timestampUrl);
            const timestamp = await timestampResponse.text();
            const strongElem = document.querySelector("#message h4 strong");
            if (strongElem) {
              strongElem.textContent = `MAJ ANFR du ${timestamp.trim()}`;
            }
          } catch (err) {
            console.warn("Impossible de charger la date:", err);
          }
          
          this.processData(rows);
          
        } catch (error) {
          console.error('Erreur lors du chargement des données:', error);
          const strongElem = document.querySelector("#message h4 strong");
          if (strongElem) {
            strongElem.textContent = "Erreur de chargement des données";
            strongElem.style.color = "red";
          }
        }
      }

      processData(rows) {
        // Regrouper par support + opérateur
        const groupedData = {};
        
        rows.forEach(row => {
          const key = `${row.id_support}_${row.operateur}`;
          if (!groupedData[key]) {
            groupedData[key] = [];
          }
          groupedData[key].push(row);
        });

        // Créer les marqueurs et stocker les données
        Object.entries(groupedData).forEach(([key, supportRows]) => {
          const marker = Utils.createMarker(supportRows);
          if (marker) {
            const [lat, lon] = supportRows[0].coordonnees.split(',').map(parseFloat);
            this.dataStore.addSupport(key, {
              marker,
              data: supportRows,
              coords: { lat, lon }
            });
          }
        });

        // Initialiser l'affichage
        const allSupports = Array.from(this.dataStore.supports.values());
        this.mapManager.updateMarkers(allSupports);
      }

      initSearch() {
        const searchInput = document.getElementById('searchInput');
        if (searchInput) {
          searchInput.addEventListener('input', (e) => {
            const value = e.target.value.trim();
            this.searchManager.handleInput(value);
            
            // Afficher/masquer la croix selon s'il y a du texte
            const clearButton = document.getElementById('clearSearch');
            if (clearButton) {
              clearButton.style.display = value ? 'flex' : 'none';
            }
          });
        }
        
        // Attendre que le DOM soit prêt pour attacher l'événement à la croix
        setTimeout(() => {
          const clearButton = document.getElementById('clearSearch');
          if (clearButton) {
            clearButton.addEventListener('click', (e) => {
              e.stopPropagation();
              const searchInput = document.getElementById('searchInput');
              if (searchInput) {
                searchInput.value = '';
                this.searchManager.hideResults();
                searchInput.focus();
              }
              clearButton.style.display = 'none';
            });
          }
        }, 100);
      }
    }

    // Initialisation de l'application
    let app;
    document.addEventListener('DOMContentLoaded', () => {
      app = new ANFRApp();
    });

    // Variables globales pour compatibilité (si nécessaire)
    let mapManager, dataStore, searchManager, filterManager;
    
    // Exposer les managers si besoin pour le debugging
    window.debugApp = () => ({
      dataStore: app?.dataStore,
      mapManager: app?.mapManager,
      searchManager: app?.searchManager,
      filterManager: app?.filterManager
    });

  </script>
</body>
</html>
